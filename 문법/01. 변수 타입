기본타입 / 참조타입 / 상수 / 배열 / 리스트 / 집합, 맵 / 제네릭 / 

1. 기본 타입
byte n = 100; // -128 ~ 127 (1바이트 = 8비트)
short n = 100; // 대략 ±3만 (2바이트)
int n = 100; // 대략 ±2*10^9 (3바이트)
long n = 100L; // 뒤에 L을 붙여야 한다. (대문자 권장) (4바이트)
float x = 3.14F; // 뒤에 F(혹은 f)를 붙여야 한다.
double x = 3.14;
boolean isnum = true; // true or false (파이썬과 다르게 소문자로 시작)
char c = 'A'; // 문자, 아스키코드 (파이썬과 다르게 문자열과 구분된다.)

* 캐스팅
기본 타입의 크기는 char < int < long < float < double 순이다.
큰 타입은 작은 타입의 값을 바로 받을 수 있지만, 작은 타입은 캐스팅을 통해 받을 수 있다.
(예시)
int i = 10;
double d = 3.14;
double conv1 = i; // 10.0
int conv2 = (int) d; // 3
int error = d; // 에러

* 래퍼 클래스
기본 타입을 객체로 다루기 위해 사용하는 클래스를 wrapper class라고 한다.
대부분 기본 타입의 첫 문자를 대문자로 쓴 것을 이름으로 가지며,
int와 char만 각각 Integer, Character로 이름을 갖는다.
(예시)
Integer a = new Integer(10); // 박싱
int b = a.intValue(); // 언박싱

Integer a = 10; // 오토박싱
int b = a; // 오토언박싱

2. 참조 타입
class, interface 등이 있으며, new 키워드로 객체를 생성해서 사용한다.
단, String은 기본 타입처럼 사용한다.
(예시)
String s = "abc";
Pos p = new Pos();

3. 상수
클래스에서 static final 키워드로 선언하며, 초기화하면서 선언해야 한다.
- static 키워드
a. 정적이라는 의미
클래스 객체를 생성하지 않아도 메모리에 할당되어 있으며, 프로그램 종료시에 해제된다.
따라서 객체를 생성하지 않아도 접근 가능하다.
객체가 할당되는 heap 영역과 대비되며, heap 영역은 GC의 관리를 받고, static 영역은 그렇지 않다.
아래에 나올 final 키워드가 값을 잠그는 용도라면, static은 메모리 주소를 잠그며 이것을 정적이라고 표현한다.
b. 공유라는 기능
메모리 주소가 고정되므로 해당 변수를 어디서 사용하든 해당 메모리 주소에 대해 수행한다.
어떤 메소드에서 static 변수를 조작하면, 다른 메소드도 영향을 받는다.
c. 선언 위치
따라서 static 변수는 클래스 메소드 외부에 선언한다.
- final 키워드
값이 정해지면 변경이 불가하다.
(예시)
public class Class1 {
    public static final int ZERO = 0;
    ...
}

* MATH.PI와 MATH.E도 상수로 지정되어 있다.

4. 배열
영어로는 array이며, Array로 제공되는 변수타입이 있지는 않다.
리스트와 달리 길이가 고정되어 인덱싱 오류 등의 불편함이 있다.

- new 키워드로 선언 (자릿수 혹은 리터럴을 지정)
(예시)
int [] nums = new int[4]; // {0, 0, 0, 0}. 자릿수만 입력하면 default 값으로 초기화.
nums = new int[]{2, 3, 4} // {2, 3, 4}로 재초기화. 길이가 달라도 된다.
nums[0] = 1; // 변경 가능

C와는 다르게 자릿수에 초기화된 정수 변수를 넣을 수 있다.
(예시)
int n = 4;
int [] nums = new int[n]; // n이 값을 가지고 있어야 하며 byte, short, int형 중 하나여야 한다. (long은 불가능)

- 리터럴 대입하여 선언 (선언 시에는 리터럴을 대입할 수 있다. 하지만 재초기화는 new 키워드를 이용해야 한다.)
(예시)
int[] nums = {1, 2, 3}; // 초기화와 함께 선언된다. (파이썬과 달리 대괄호가 아니라 중괄호다.)
nums[0] = 2; // 변경 가능
nums = new int[]{2, 3, 4, 5}; // 길이가 달라도 됨.
nums = {2, 3, 4, 5}; // 에러

5. 리스트
- 배열리스트: 접근과 수정에 유리(인덱싱)
- 연결리스트: 추가와 제거에 유리, 메모리 공간이 불연속적이다.
(예시) 배열리스트
import java.util.ArrayList;

ArrayList list1 = new ArrayList<Integer>(); // <>안에 타입을 지정하며, 생략 가능하다.
* 괄호 안에 값을 넣어서 초기화할 수도 있다. 이것은 Set이나 Map도 동일하다.
- (10); // 초기 용량을 설정
- (list0); // 다른 ArrayList로 초기화(Set로도 초기화 가능)
- (Arrays.asList(1, 2, 3)); // 기본값들로 초기화 // import java.util.Arrays;

list1.contains(1); // 값 1을 포함하는지 확인 (true or false)
list1.size(); // 배열 크기 리턴
list1.get(1); // 두 번째 자리의 값 리턴
list1.indexOf(1); // 1이 있는 인덱스 리턴 (없으면 -1 리턴)
list1.add(1); // 마지막 자리에 값 1 추가
list1.add(0, 1); // 첫 번째 자리에 값 1 추가 (뒤의 원소들은 한 칸씩 밀림)
list1.set(0, 2); // 첫 번째 자리의 값을 2로 변경
list1.remove(0); // 첫 번째 자리의 값 제거 (인덱스로 제거. default는 첫 번째 자리이다.)
list1.remove(Integer.valueOf(1)); // 가장 앞에 있는 1 제거 (값으로 제거)
- 만약 원소가 문자열이었다면, 값으로 제거하는 방법이 좀 더 간단하다.
  list2.remove("abc");
- 모든 1을 제거하려면 while문을 이용한다.
  while (list1.remove(Integer.valueOf(1))) {
  };
list1.clear();

(예시) 연결리스트
import java.util.LinkedList;

LinkedList list1 = new LinkedList<Integer>();
list1.addFirst(1);
list1.addLast(1); // add(1)과 동일
list1.removeFirst(); // remove()와 동일
list1.removeLast();

(예시) 출력
// List, Set, Map 등은 print함수로 출력할 수 있다.
System.out.println(lst); // [1, 2, 3]
System.out.println(set); // [1, 2, 3]
System.out.println(map); // {"one"=1, "two"=2, "three"=3}

// 배열처럼 for-each나 iterator를 이용할 수도 있다.
// for-each
for (Integer value: list1) {
    System.out.println(value);
}

// iterator
Iterator<Integer> iter = list1.iterator();
while (iter.hasNext()) {
    System.out.println(iter.next());
}

6. 집합, 맵
Set: Set은 집합을 정의하는 인터페이스이다. 요소가 중복되지 않는다. 
- HashSet: 일반적인 set
- LinkedHashSet: 추가된 순서나 접근한 순서대로 접근 가능
- TreeSet: 정렬된 순서로 저장

(예시)
import java.util.HashSet;

HashSet<Integer> set = new HashSet<Integer>();
set.add(1);
set.remove(1);
set.clear();
set.contains(1);
set.size();

Map: Key-Value 쌍을 저장
- HashMap: 키와 값으로 null 허용
- LinkedHashMao: 추가된 순서대로 접근 가능
- TreeMap: 이진검색트리 형태, 정렬된 순서로 저장

(예시)
import java.util.HashMap;

HashMap<String, String> map = new HashMap<String, String>();
map.put("people", "사람"); // add가 아닌 put을 쓴다.
map.get("people");
map.remove("people");
map.containsKey("people");
map.size();

7. 제네릭
일반타입으로, 타입을 정해놓지 않고 외부에서 정하게 한다.
암묵적으로 대문자 하나로 표시한다.
- T, E, K, V, N (Type, Element, Key, Value, Number)

(예시)
public class ClassName <T> {}
public class HashMap <K, V> {}
public interface List<E> extends Collenction<E> {} // <E>는 붙여쓴다.

(예시) 기본 get/set 구현
public class ClassName<E> {

    private E element;
    
    void set(E element) {
        this.element = element;
    }
    
    E get() {
        return element;
    }
}

8. 이넘
enum Direction {EAST, WEST, SOUTH, NORTH}
- 클래스처럼 쌍봉낙타이며 마찬가지로 뒤에 세미콜론을 붙이지 않는다.
  의미는 명사
- 원소들은 상수처럼 대문자로만 쓴다.

9. 어노테이션
public @interface FunctionalInterface {}
public @Async Documented {}
public @Test Documented {}
- 인터페이스처럼 쌍봉낙타이며 마찬가지로 뒤에 세미콜론을 붙이지 않는다.
  의미는 동일하게 형용사거나 Interface 같은 패밀리는 명사
  인터페이스는 -able 류의 형용사가 많고, 어노테이션은 -ed 류의 형용사가 많다.
  
